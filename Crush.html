<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Crystal Crush</title>

<style>
:root {
  --bg-color: #f2f6f4;
  --grid-color: #cfded7;
  --font-color: #000;
}

body {
  margin: 0;
  padding: 100px 20px 20px;
  font-family: 'Inter', sans-serif;
  background: var(--bg-color);
  color: var(--font-color);
  display: flex;
  justify-content: center;
}

.app {
  max-width: 360px;
  width: 100%;
}

.title {
  text-align: center;
  font-size: 22px;
  font-weight: 600;
  margin-bottom: 20px;
}

.grid-wrapper {
  width: 100%;
  aspect-ratio: 5 / 9;
}

.grid {
  display: grid;
  width: 100%;
  height: 100%;
  background: white;
  border: 2px solid var(--grid-color);
}

.cell {
  border: 1px solid var(--grid-color);
  display: flex;
  align-items: center;
  justify-content: center;
}

.cell img {
  width: 80%;
  height: 80%;
  object-fit: contain;
  pointer-events: none;
}

.cell:empty {
  background: #ffffff;
}
</style>
</head>

<body>
<div class="app">
  <div class="title" id="gameTitle">Loadingâ€¦</div>
  <div class="grid-wrapper">
    <div class="grid" id="grid"></div>
  </div>
</div>

<script>
/* =======================
   SUPABASE CONFIG
======================= */
const SUPABASE_URL = "https://tppyzexttkuvcobbbmaz.supabase.co";
const SUPABASE_ANON_KEY = "sb_publishable_VZiTsc0JGVx6tVf2Zu-9uQ_-FwjGpQW";

/* =======================
   GAME STATE
======================= */
let games = [];
let currentGame = null;

let gridRows = 9;
let gridCols = 5;
let itemTypes = 5;

let images = {};
let gridData = [];

let touchStartX = 0;
let touchStartY = 0;
let touchStartCell = null;

/* =======================
   ELEMENTS
======================= */
const gridEl = document.getElementById("grid");
const titleEl = document.getElementById("gameTitle");

/* =======================
   LOAD GAMES
======================= */
async function loadGames() {
  const res = await fetch(
    `${SUPABASE_URL}/rest/v1/GamesCrush?Active=eq.true&order=StartDate.desc`,
    {
      headers: {
        apikey: SUPABASE_ANON_KEY,
        Authorization: `Bearer ${SUPABASE_ANON_KEY}`
      }
    }
  );

  games = await res.json();

  if (!games.length) {
    titleEl.textContent = "No active games";
    return;
  }

  initGame(games[0]);
}

/* =======================
   INIT GAME
======================= */
function initGame(game) {
  currentGame = game;

  gridRows = game.GridRows;
  gridCols = game.GridCols;
  itemTypes = game.ItemTypes;

  images = game.ImagesJson;

  document.documentElement.style.setProperty('--bg-color', game.BgColor);
  document.documentElement.style.setProperty('--font-color', game.FontColor);

  titleEl.textContent = game.Name;

  buildEmptyGrid();
  fillGridRandomly();
  renderGrid();
}

/* =======================
   GRID LOGIC
======================= */
function buildEmptyGrid() {
  gridData = Array.from({ length: gridRows }, () =>
    Array.from({ length: gridCols }, () => null)
  );
}

function fillGridRandomly() {
  for (let r = 0; r < gridRows; r++) {
    for (let c = 0; c < gridCols; c++) {
      gridData[r][c] = randomItem();
    }
  }
}

function randomItem() {
  return Math.floor(Math.random() * itemTypes) + 1;
}

/* =======================
   RENDER
======================= */
function renderGrid() {
  gridEl.innerHTML = "";
  gridEl.style.gridTemplateColumns = `repeat(${gridCols}, 1fr)`;
  gridEl.style.gridTemplateRows = `repeat(${gridRows}, 1fr)`;

  gridData.forEach((row, r) => {
    row.forEach((val, c) => {
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.row = r;
      cell.dataset.col = c;

      cell.addEventListener("touchstart", handleTouchStart, { passive: true });
      cell.addEventListener("touchend", handleTouchEnd, { passive: true });

      if (val !== null) {
        const img = document.createElement("img");
        img.src = images[val];
        cell.appendChild(img);
      }

      gridEl.appendChild(cell);
    });
  });
}

/* =======================
   MATCH DETECTION + REMOVAL
======================= */
function hasMatchAt(row, col) {
  const value = gridData[row][col];
  if (!value) return false;

  let count = 1;
  // Horizontal
  for (let c = col - 1; c >= 0 && gridData[row][c] === value; c--) count++;
  for (let c = col + 1; c < gridCols && gridData[row][c] === value; c++) count++;
  if (count >= 3) return true;

  count = 1;
  // Vertical
  for (let r = row - 1; r >= 0 && gridData[r][col] === value; r--) count++;
  for (let r = row + 1; r < gridRows && gridData[r][col] === value; r++) count++;
  return count >= 3;
}

function findMatches() {
  const matches = new Set();

  // Horizontal matches
  for (let r = 0; r < gridRows; r++) {
    let count = 1;
    for (let c = 1; c <= gridCols; c++) {
      if (
        c < gridCols &&
        gridData[r][c] === gridData[r][c - 1] &&
        gridData[r][c] !== null
      ) {
        count++;
      } else {
        if (count >= 3) {
          for (let k = 0; k < count; k++) {
            matches.add(`${r},${c - 1 - k}`);
          }
        }
        count = 1;
      }
    }
  }

  // Vertical matches
  for (let c = 0; c < gridCols; c++) {
    let count = 1;
    for (let r = 1; r <= gridRows; r++) {
      if (
        r < gridRows &&
        gridData[r][c] === gridData[r - 1][c] &&
        gridData[r][c] !== null
      ) {
        count++;
      } else {
        if (count >= 3) {
          for (let k = 0; k < count; k++) {
            matches.add(`${r - 1 - k},${c}`);
          }
        }
        count = 1;
      }
    }
  }

  return matches;
}

function removeMatches(matches) {
  matches.forEach(key => {
    const [r, c] = key.split(',').map(Number);
    gridData[r][c] = null;
  });
}

/* =======================
   TOUCH + SWAP
======================= */
function handleTouchStart(e) {
  const touch = e.touches[0];
  const cell = e.currentTarget;

  touchStartX = touch.clientX;
  touchStartY = touch.clientY;

  touchStartCell = {
    row: Number(cell.dataset.row),
    col: Number(cell.dataset.col)
  };
}

function handleTouchEnd(e) {
  if (!touchStartCell) return;

  const touch = e.changedTouches[0];
  const dx = touch.clientX - touchStartX;
  const dy = touch.clientY - touchStartY;

  const absX = Math.abs(dx);
  const absY = Math.abs(dy);

  if (Math.max(absX, absY) < 20) {
    resetTouch();
    return;
  }

  let targetRow = touchStartCell.row;
  let targetCol = touchStartCell.col;

  if (absX > absY) {
    targetCol += dx > 0 ? 1 : -1;
  } else {
    targetRow += dy > 0 ? 1 : -1;
  }

  attemptSwapWithTarget(targetRow, targetCol);
  resetTouch();
}

function attemptSwapWithTarget(r2, c2) {
  const r1 = touchStartCell.row;
  const c1 = touchStartCell.col;

  if (r2 < 0 || r2 >= gridRows || c2 < 0 || c2 >= gridCols) return;

  swapCells(r1, c1, r2, c2);

  const matches = findMatches();

  if (matches.size > 0) {
    removeMatches(matches);
  } else {
    swapCells(r1, c1, r2, c2);
  }

  renderGrid();
}

function swapCells(r1, c1, r2, c2) {
  const temp = gridData[r1][c1];
  gridData[r1][c1] = gridData[r2][c2];
  gridData[r2][c2] = temp;
}

function resetTouch() {
  touchStartCell = null;
}

/* =======================
   INIT
======================= */
loadGames();
</script>
</body>
</html>
