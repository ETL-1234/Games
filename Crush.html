<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Crystal Crush</title>

<style>
:root {
  --bg-color: #f2f6f4;
  --grid-color: #cfded7;
  --font-color: #000;
}

body {
  margin: 0;
  padding: 100px 20px 20px;
  font-family: 'Inter', sans-serif;
  background: var(--bg-color);
  color: var(--font-color);
  display: flex;
  justify-content: center;
}

.app {
  max-width: 360px;
  width: 100%;
}

.title {
  text-align: center;
  font-size: 22px;
  font-weight: 600;
  margin-bottom: 20px;
}

.grid-wrapper {
  width: 100%;
  aspect-ratio: 5 / 9;
}

.grid {
  display: grid;
  width: 100%;
  height: 100%;
  background: white;
  border: 2px solid var(--grid-color);
}

.cell {
  border: 1px solid var(--grid-color);
  display: flex;
  align-items: center;
  justify-content: center;
}

.cell img {
  width: 80%;
  height: 80%;
  object-fit: contain;
  pointer-events: none;
}
</style>
</head>

<body>
<div class="app">
  <div class="title" id="gameTitle">Loadingâ€¦</div>
  <div class="grid-wrapper">
    <div class="grid" id="grid"></div>
  </div>
</div>

<script>
/* =======================
   SUPABASE CONFIG
======================= */
const SUPABASE_URL = "https://tppyzexttkuvcobbbmaz.supabase.co";
const SUPABASE_ANON_KEY = "sb_publishable_VZiTsc0JGVx6tVf2Zu-9uQ_-FwjGpQW";

/* =======================
   GAME STATE
======================= */
let games = [];
let currentGame = null;

let gridRows = 9;
let gridCols = 5;
let itemTypes = 5;

let images = {};
let gridData = [];

let touchStartX = 0;
let touchStartY = 0;

let touchStartCell = null;
let touchEndCell = null;

/* =======================
   ELEMENTS
======================= */
const gridEl = document.getElementById("grid");
const titleEl = document.getElementById("gameTitle");

/* =======================
   LOAD GAMES
======================= */
async function loadGames() {
  const res = await fetch(
    `${SUPABASE_URL}/rest/v1/GamesCrush?Active=eq.true&order=StartDate.desc`,
    {
      headers: {
        apikey: SUPABASE_ANON_KEY,
        Authorization: `Bearer ${SUPABASE_ANON_KEY}`
      }
    }
  );

  games = await res.json();

  if (!games.length) {
    titleEl.textContent = "No active games";
    return;
  }

  initGame(games[0]);
}

/* =======================
   INIT GAME
======================= */
function initGame(game) {
  currentGame = game;

  gridRows = game.GridRows;
  gridCols = game.GridCols;
  itemTypes = game.ItemTypes;

  images = game.ImagesJson;

  document.documentElement.style.setProperty('--bg-color', game.BgColor);
  document.documentElement.style.setProperty('--font-color', game.FontColor);

  titleEl.textContent = game.Name;

  buildEmptyGrid();
  fillGridRandomly();
  renderGrid();
}

/* =======================
   GRID LOGIC
======================= */
function buildEmptyGrid() {
  gridData = Array.from({ length: gridRows }, () =>
    Array.from({ length: gridCols }, () => null)
  );
}

function fillGridRandomly() {
  for (let r = 0; r < gridRows; r++) {
    for (let c = 0; c < gridCols; c++) {
      gridData[r][c] = randomItem();
    }
  }
}

function randomItem() {
  return Math.floor(Math.random() * itemTypes) + 1;
}

/* =======================
   RENDER
======================= */
function renderGrid() {
  gridEl.innerHTML = "";
  gridEl.style.gridTemplateColumns = `repeat(${gridCols}, 1fr)`;
  gridEl.style.gridTemplateRows = `repeat(${gridRows}, 1fr)`;

  gridData.forEach((row, r) => {
    row.forEach((val, c) => {
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.row = r;
      cell.dataset.col = c;

     cell.addEventListener("touchstart", handleTouchStart, { passive: true });
     cell.addEventListener("touchend", handleTouchEnd, { passive: true });

      const img = document.createElement("img");
      img.src = images[val];
      cell.appendChild(img);

      gridEl.appendChild(cell);
    });
  });
}
/* =======================
   START (TOUCH + SWAP)
======================= */

function handleTouchStart(e) {
  const touch = e.touches[0];
  const cell = e.currentTarget;

  touchStartX = touch.clientX;
  touchStartY = touch.clientY;

  touchStartCell = {
    row: Number(cell.dataset.row),
    col: Number(cell.dataset.col)
  };
}

function handleTouchEnd(e) {
  if (!touchStartCell) return;

  const touch = e.changedTouches[0];
  const dx = touch.clientX - touchStartX;
  const dy = touch.clientY - touchStartY;

  const absX = Math.abs(dx);
  const absY = Math.abs(dy);

  // Ignore tiny movements
  if (Math.max(absX, absY) < 20) {
    resetTouch();
    return;
  }

  let targetRow = touchStartCell.row;
  let targetCol = touchStartCell.col;

  // Decide swipe direction
  if (absX > absY) {
    targetCol += dx > 0 ? 1 : -1;
  } else {
    targetRow += dy > 0 ? 1 : -1;
  }

  attemptSwapWithTarget(targetRow, targetCol);
  resetTouch();
}

function attemptSwapWithTarget(r2, c2) {
  const r1 = touchStartCell.row;
  const c1 = touchStartCell.col;

  // Bounds check
  if (
    r2 < 0 || r2 >= gridRows ||
    c2 < 0 || c2 >= gridCols
  ) return;

  swapCells(r1, c1, r2, c2);
  renderGrid();
}

function swapCells(r1, c1, r2, c2) {
  const temp = gridData[r1][c1];
  gridData[r1][c1] = gridData[r2][c2];
  gridData[r2][c2] = temp;
}

function resetTouch() {
  touchStartCell = null;
}

  function hasMatchAt(row, col) {
  const value = gridData[row][col];
  if (!value) return false;

  // --- Horizontal check ---
  let count = 1;

  // left
  for (let c = col - 1; c >= 0 && gridData[row][c] === value; c--) {
    count++;
  }

  // right
  for (let c = col + 1; c < gridCols && gridData[row][c] === value; c++) {
    count++;
  }

  if (count >= 3) return true;

  // --- Vertical check ---
  count = 1;

  // up
  for (let r = row - 1; r >= 0 && gridData[r][col] === value; r--) {
    count++;
  }

  // down
  for (let r = row + 1; r < gridRows && gridData[r][col] === value; r++) {
    count++;
  }

  return count >= 3;
}


/* =======================
   INIT
======================= */

  loadGames();
</script>
</body>
</html>

