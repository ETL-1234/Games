<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Crystal Crush</title>

<style>
:root {
  --bg-color: #ffffff;
  --grid-color: #ffffff;
  --font-color: #000;
  --overlay-text: rgba(0,0,0,0.65);
}

  .overlay {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 32px;
  font-weight: 600;
  letter-spacing: 1px;
  color: var(--overlay-text);
  text-align: center;
  opacity: 0;
  pointer-events: none;
  z-index: 10;
  transition: opacity 1.2s ease-in-out;
  white-space: pre-line;
}


body {
  margin: 0;
  padding: 40px 20px 20px 20px;
  font-family: 'Inter', sans-serif;
  background: var(--bg-color);
  color: var(--font-color);
  display: flex;
  justify-content: center;
}

.app {
  max-width: 360px;
  width: 100%;
}

.title {
  text-align: center;
  font-size: 22px;
  font-weight: 600;
  margin-bottom: 20px;
}

  .hud {
  display: flex;
  justify-content: space-between;
  margin-bottom: 10px;
  font-size: 16px;
  font-weight: 500;
}

.score,
.moves {
  color: var(--font-color);
}

  <div class="hud">
  <div class="score" id="scoreText">Score: 0</div>
  <div class="moves" id="movesText">Moves: 0</div>
</div>


.grid-wrapper {
  width: 100%;
  aspect-ratio: 5 / 9;
}

  <div class="overlay" id="overlayText"></div>

.grid {
  display: grid;
  width: 100%;
  height: 100%;
  background: white;
  border: 2px solid var(--grid-color);
}

.cell {
  border: 1px solid var(--grid-color);
  display: flex;
  align-items: center;
  justify-content: center;
}

.cell img {
  width: 80%;
  height: 80%;
  object-fit: contain;
  pointer-events: none;
  transition: transform 0.4s ease, filter 0.4s ease;
}

  /* Swap animation */
.cell.swap-right img { transform: translateX(100%); }
.cell.swap-left img  { transform: translateX(-100%); }
.cell.swap-down img  { transform: translateY(100%); }
.cell.swap-up img    { transform: translateY(-100%); }

.cell img {
  transition: transform 0.25s ease, filter 0.4s ease;
}

  
/* ================= MATCH ANIMATION ================= */
.cell.match img {
  transform: scale(1.25);
  filter: drop-shadow(0 0 15px gold);
}

/* Falling animation */
.cell img {
  transition: transform 0.35s ease;
}

.cell img.fall {
  transform: translateY(calc(var(--fall) * -100%));
}

  
</style>
</head>

<body>
<div class="app">
  <div class="title" id="gameTitle">Loadingâ€¦</div>
  <div class="grid-wrapper">
    <div class="grid" id="grid"></div>
  </div>
</div>

<script>
const SUPABASE_URL = "https://tppyzexttkuvcobbbmaz.supabase.co";
const SUPABASE_ANON_KEY = "sb_publishable_VZiTsc0JGVx6tVf2Zu-9uQ_-FwjGpQW";

let gridRows = 9, gridCols = 5, itemTypes = 5;
let images = {}, gridData = [];
let touchStartCell = null;
let touchStartX = 0, touchStartY = 0;

const gridEl = document.getElementById("grid");
const titleEl = document.getElementById("gameTitle");

/* ================= INIT ================= */
async function loadGames() {
  const res = await fetch(
    `${SUPABASE_URL}/rest/v1/GamesCrush?Active=eq.true&order=StartDate.desc`,
    { headers:{apikey:SUPABASE_ANON_KEY,Authorization:`Bearer ${SUPABASE_ANON_KEY}`}}
  );
  const games = await res.json();
  if (!games.length) return;
  initGame(games[0]);
}

/* ================= GAME INIT ================= */
function initGame(game) {
  gridRows = game.GridRows;
  gridCols = game.GridCols;
  itemTypes = game.ItemTypes;
  images = game.ImagesJson;

  document.documentElement.style.setProperty('--bg-color', game.BgColor);
  document.documentElement.style.setProperty('--font-color', game.FontColor);
  titleEl.textContent = game.Name;

  buildGridNoMatches();
  renderGrid();
}

  score = 0;
movesLeft = game.Moves; // â† from Supabase

updateHUD();

  function updateHUD() {
  scoreEl.textContent = `Score: ${score}`;
  movesEl.textContent = `Moves: ${movesLeft}`;
}



/* ================= GRID BUILD ================= */
function buildGridNoMatches() {
  do {
    gridData = Array.from({length: gridRows}, () =>
      Array.from({length: gridCols}, () => randomItem())
    );
  } while (findMatches().size > 0);
}

function randomItem() {
  return Math.floor(Math.random() * itemTypes) + 1;
}

/* ================= RENDER ================= */

function renderGrid(fallMap = null) {

  // â›” DO NOT wipe grid during animations
  gridEl.innerHTML = "";

  gridEl.style.gridTemplateColumns = `repeat(${gridCols}, 1fr)`;
  gridEl.style.gridTemplateRows = `repeat(${gridRows}, 1fr)`;

  const animatedImages = [];

  for (let r = 0; r < gridRows; r++) {
    for (let c = 0; c < gridCols; c++) {
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.row = r;
      cell.dataset.col = c;

      cell.addEventListener("touchstart", handleTouchStart, { passive: true });
      cell.addEventListener("touchend", handleTouchEnd, { passive: true });

      const value = gridData[r][c];
      if (value !== null) {
        const img = document.createElement("img");
        img.src = images[value];

        // ðŸ”¥ IMPORTANT: apply offset BEFORE render
        if (fallMap && fallMap[r][c] > 0) {
          img.style.transform = `translateY(${fallMap[r][c] * -100}%)`;
          animatedImages.push(img);
        }

        cell.appendChild(img);
      }

      gridEl.appendChild(cell);
    }
  }

  // ðŸ”¥ NEXT FRAME â†’ animate to zero
  requestAnimationFrame(() => {
    animatedImages.forEach(img => {
      img.style.transform = "translateY(0)";
    });
  });
}

/* ================= MATCH FIND ================= */
function findMatches() {
  const matches = new Set();

  for (let r = 0; r < gridRows; r++) {
    for (let c = 0; c < gridCols - 2; c++) {
      const v = gridData[r][c];
      if (v && v === gridData[r][c+1] && v === gridData[r][c+2]) {
        matches.add(`${r},${c}`);
        matches.add(`${r},${c+1}`);
        matches.add(`${r},${c+2}`);
      }
    }
  }

  for (let c = 0; c < gridCols; c++) {
    for (let r = 0; r < gridRows - 2; r++) {
      const v = gridData[r][c];
      if (v && v === gridData[r+1][c] && v === gridData[r+2][c]) {
        matches.add(`${r},${c}`);
        matches.add(`${r+1},${c}`);
        matches.add(`${r+2},${c}`);
      }
    }
  }

  return matches;
}

/* ================= MATCH ANIMATION ================= */
async function animateMatches(matches) {
  matches.forEach(key => {
    const [r, c] = key.split(',').map(Number);
    const cell = gridEl.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
    if (cell) cell.classList.add("match");
  });

  await new Promise(r => setTimeout(r, 400));

  matches.forEach(key => {
    const [r, c] = key.split(',').map(Number);
    gridData[r][c] = null;
  });

 const fallMap = applyGravity();

// ðŸ‘‡ mark NEW tiles as falling from above
for (let c = 0; c < gridCols; c++) {
  for (let r = 0; r < gridRows; r++) {
    if (fallMap[r][c] === 0 && gridData[r][c] !== null) {
      // new tiles fall from above the grid
      if (!fallMap[r][c]) {
        fallMap[r][c] = r + 1;
      }
    }
  }
}

refillGrid();
renderGrid(fallMap);


  const next = findMatches();
  if (next.size > 0) await animateMatches(next);
}

/* ================= GRAVITY + REFILL ================= */

function applyGravity() {
  const fallMap = Array.from({ length: gridRows }, () =>
    Array(gridCols).fill(0)
  );

  for (let c = 0; c < gridCols; c++) {
    let writeRow = gridRows - 1;

    for (let r = gridRows - 1; r >= 0; r--) {
      if (gridData[r][c] !== null) {
        if (writeRow !== r) {
          gridData[writeRow][c] = gridData[r][c];
          gridData[r][c] = null;
          fallMap[writeRow][c] = writeRow - r;
        }
        writeRow--;
      }
    }
  }

  return fallMap;
}

function refillGrid() {
  for (let c = 0; c < gridCols; c++) {
    let emptyCount = 0;

    for (let r = gridRows - 1; r >= 0; r--) {
      if (gridData[r][c] === null) {
        emptyCount++;
      } else if (emptyCount > 0) {
        // existing tiles already handled by gravity
      }
    }

    // Fill from top
    for (let r = 0; r < gridRows; r++) {
      if (gridData[r][c] === null) {
        gridData[r][c] = randomItem();
      }
    }
  }
}



/* ================= TOUCH + SWAP ================= */
function handleTouchStart(e) {
  const cell = e.currentTarget;
  const t = e.touches[0];
  touchStartX = t.clientX;
  touchStartY = t.clientY;
  touchStartCell = { row:+cell.dataset.row, col:+cell.dataset.col };
}

function handleTouchEnd(e) {
  if (!touchStartCell) return;
  const t = e.changedTouches[0];
  const dx = t.clientX - touchStartX;
  const dy = t.clientY - touchStartY;

  if (Math.max(Math.abs(dx), Math.abs(dy)) < 20) return;

  let r2 = touchStartCell.row;
  let c2 = touchStartCell.col;
  Math.abs(dx) > Math.abs(dy) ? c2 += dx > 0 ? 1 : -1 : r2 += dy > 0 ? 1 : -1;

  attemptSwap(r2, c2);
  touchStartCell = null;
}

async function attemptSwap(r2, c2) {
  const { row: r1, col: c1 } = touchStartCell;
  if (r2 < 0 || c2 < 0 || r2 >= gridRows || c2 >= gridCols) return;

  const cell1 = gridEl.querySelector(`.cell[data-row='${r1}'][data-col='${c1}']`);
  const cell2 = gridEl.querySelector(`.cell[data-row='${r2}'][data-col='${c2}']`);

  const dx = c2 - c1;
  const dy = r2 - r1;

  if (dx === 1) { cell1.classList.add('swap-right'); cell2.classList.add('swap-left'); }
  if (dx === -1){ cell1.classList.add('swap-left');  cell2.classList.add('swap-right'); }
  if (dy === 1) { cell1.classList.add('swap-down');  cell2.classList.add('swap-up'); }
  if (dy === -1){ cell1.classList.add('swap-up');    cell2.classList.add('swap-down'); }

  await new Promise(r => setTimeout(r, 250));

  swap(r1, c1, r2, c2);
  renderGrid();

  const matches = findMatches();
 if (matches.size) {
  movesLeft--;
  updateHUD();

  await animateMatches(matches);

  if (movesLeft <= 0) {
    endGame();
  }
} else {
  swap(r1, c1, r2, c2);
  renderGrid();
}
}


function swap(r1,c1,r2,c2){
  [gridData[r1][c1], gridData[r2][c2]] =
  [gridData[r2][c2], gridData[r1][c1]];
}

/* ================= START ================= */
loadGames();
</script>
</body>
</html>
