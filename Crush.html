<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Crystal Crush</title>

<style>
:root {
  --bg-color: #f2f6f4;
  --grid-color: #cfded7;
  --font-color: #000;
}

body {
  margin: 0;
  padding: 60px 20px 20px;
  font-family: 'Inter', sans-serif;
  background: var(--bg-color);
  color: var(--font-color);
  display: flex;
  justify-content: center;
}

.app {
  max-width: 360px;
  width: 100%;
}

.title {
  text-align: center;
  font-size: 22px;
  font-weight: 600;
  margin-bottom: 20px;
}

.grid-wrapper {
  width: 100%;
  aspect-ratio: 5 / 9;
}

.grid {
  display: grid;
  width: 100%;
  height: 100%;
  background: white;
  border: 2px solid var(--grid-color);
}

.cell {
  border: 1px solid var(--grid-color);
  display: flex;
  align-items: center;
  justify-content: center;
}

.cell img {
  width: 80%;
  height: 80%;
  object-fit: contain;
  pointer-events: none;
  transition: transform 0.3s ease, filter 0.3s ease;
}

/* Match highlight animation */
.cell.match img {
  transform: scale(1.4);
  filter: drop-shadow(0 0 15px gold);
}
</style>
</head>
<body>
<div class="app">
  <div class="title" id="gameTitle">Loadingâ€¦</div>
  <div class="grid-wrapper">
    <div class="grid" id="grid"></div>
  </div>
</div>

<script>
const SUPABASE_URL = "https://tppyzexttkuvcobbbmaz.supabase.co";
const SUPABASE_ANON_KEY = "sb_publishable_VZiTsc0JGVx6tVf2Zu-9uQ_-FwjGpQW";

let games = [], currentGame = null;
let gridRows = 9, gridCols = 5, itemTypes = 5;
let images = {}, gridData = [];
let touchStartX = 0, touchStartY = 0, touchStartCell = null;
const gridEl = document.getElementById("grid");
const titleEl = document.getElementById("gameTitle");

/* ================= INIT ================= */
async function loadGames() {
  const res = await fetch(`${SUPABASE_URL}/rest/v1/GamesCrush?Active=eq.true&order=StartDate.desc`,
    { headers:{apikey:SUPABASE_ANON_KEY,Authorization:`Bearer ${SUPABASE_ANON_KEY}`}});
  games = await res.json();
  if(!games.length){ titleEl.textContent="No active games"; return;}
  initGame(games[0]);
}

/* ================= GAME INIT ================= */
function initGame(game){
  currentGame=game;
  gridRows=game.GridRows; gridCols=game.GridCols; itemTypes=game.ItemTypes;
  images=game.ImagesJson;
  document.documentElement.style.setProperty('--bg-color', game.BgColor);
  document.documentElement.style.setProperty('--font-color', game.FontColor);
  titleEl.textContent=game.Name;

  buildEmptyGrid();
  fillGridNoMatches(); // Ensure no starting matches
  renderGrid();
}

/* ================= GRID ================= */
function buildEmptyGrid(){ 
  gridData=Array.from({length:gridRows},()=>Array.from({length:gridCols},()=>null));
}

function fillGridNoMatches(){
  do{ fillGridRandomly(); } while(findMatches().size>0);
}

function fillGridRandomly(){
  for(let r=0;r<gridRows;r++) 
    for(let c=0;c<gridCols;c++) 
      gridData[r][c]=randomItem();
}

function randomItem(){ return Math.floor(Math.random()*itemTypes)+1; }

/* ================= RENDER ================= */
function renderGrid(){
  gridEl.innerHTML="";
  gridEl.style.gridTemplateColumns=`repeat(${gridCols},1fr)`;
  gridEl.style.gridTemplateRows=`repeat(${gridRows},1fr)`;
  
  for(let r=0;r<gridRows;r++){
    for(let c=0;c<gridCols;c++){
      const cell=document.createElement("div");
      cell.className="cell"; 
      cell.dataset.row=r; cell.dataset.col=c;
      cell.addEventListener("touchstart",handleTouchStart,{passive:true});
      cell.addEventListener("touchend",handleTouchEnd,{passive:true});
      if(gridData[r][c]!==null){
        const img=document.createElement("img");
        img.src=images[gridData[r][c]];
        cell.appendChild(img);
      }
      gridEl.appendChild(cell);
    }
  }
}

/* ================= MATCH DETECTION ================= */
function findMatches(){
  const matches=new Set();
  // horizontal
  for(let r=0;r<gridRows;r++){
    let count=1;
    for(let c=1;c<=gridCols;c++){
      if(c<gridCols && gridData[r][c]===gridData[r][c-1] && gridData[r][c]!==null) count++;
      else{ if(count>=3) for(let k=0;k<count;k++) matches.add(`${r},${c-1-k}`); count=1;}
    }
  }
  // vertical
  for(let c=0;c<gridCols;c++){
    let count=1;
    for(let r=1;r<=gridRows;r++){
      if(r<gridRows && gridData[r][c]===gridData[r-1][c] && gridData[r][c]!==null) count++;
      else{ if(count>=3) for(let k=0;k<count;k++) matches.add(`${r-1-k},${c}`); count=1;}
    }
  }
  return matches;
}

/* ================= ANIMATE MATCHES ================= */
async function animateMatches(matches){
  if(matches.size===0) return;

  // Highlight matched images
  matches.forEach(key=>{
    const [r,c]=key.split(',').map(Number);
    const cell = gridEl.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
    if(cell && cell.firstChild) cell.firstChild.classList.add('match');
  });

  // Wait for CSS animation to show
  await new Promise(res=>setTimeout(res,400));

  // Remove matched items from gridData and DOM
  matches.forEach(key=>{
    const [r,c]=key.split(',').map(Number);
    gridData[r][c]=null;
    const cell = gridEl.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
    if(cell && cell.firstChild) cell.removeChild(cell.firstChild);
  });

  // Apply gravity and refill
  applyGravity();
  refillGrid();
  renderGrid();

  // Check for new matches recursively
  const newMatches = findMatches();
  if(newMatches.size>0) await animateMatches(newMatches);
}

/* ================= GRAVITY + REFILL ================= */
function applyGravity(){
  for(let c=0;c<gridCols;c++){
    for(let r=gridRows-1;r>=0;r--){
      if(gridData[r][c]===null){
        for(let k=r-1;k>=0;k--){
          if(gridData[k][c]!==null){ gridData[r][c]=gridData[k][c]; gridData[k][c]=null; break;}
        }
      }
    }
  }
}

function refillGrid(){
  for(let r=0;r<gridRows;r++) 
    for(let c=0;c<gridCols;c++) 
      if(gridData[r][c]===null) gridData[r][c]=randomItem();
}

/* ================= TOUCH + SWAP ================= */
function handleTouchStart(e){
  const touch=e.touches[0];
  const cell=e.currentTarget;
  touchStartX=touch.clientX; touchStartY=touch.clientY;
  touchStartCell={row:Number(cell.dataset.row), col:Number(cell.dataset.col)};
}

function handleTouchEnd(e){
  if(!touchStartCell) return;
  const touch=e.changedTouches[0];
  const dx=touch.clientX-touchStartX;
  const dy=touch.clientY-touchStartY;
  if(Math.max(Math.abs(dx),Math.abs(dy))<20){ resetTouch(); return; }
  
  let targetRow=touchStartCell.row;
  let targetCol=touchStartCell.col;
  if(Math.abs(dx)>Math.abs(dy)) targetCol+=dx>0?1:-1;
  else targetRow+=dy>0?1:-1;
  
  attemptSwap(targetRow,targetCol);
  resetTouch();
}

async function attemptSwap(r2,c2){
  const r1=touchStartCell.row, c1=touchStartCell.col;
  if(r2<0||r2>=gridRows||c2<0||c2>=gridCols) return;

  swapCells(r1,c1,r2,c2);
  renderGrid();

  const matches=findMatches();
  if(matches.size>0) await animateMatches(matches);
  else { swapCells(r1,c1,r2,c2); renderGrid(); }
}

function swapCells(r1,c1,r2,c2){
  const temp=gridData[r1][c1]; gridData[r1][c1]=gridData[r2][c2]; gridData[r2][c2]=temp;
}

function resetTouch(){ touchStartCell=null; }

/* ================= INIT ================= */
loadGames();
</script>
</body>
</html>
