<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Crystal Crush</title>

<style>
:root {
  --bg-color: #f2f6f4;
  --grid-color: #f2f6f4;
  --font-color: #000;
}

body {
  margin: 0;
  padding: 40px 20px 20px 20px;
  font-family: 'Inter', sans-serif;
  background: var(--bg-color);
  color: var(--font-color);
  display: flex;
  justify-content: center;
}

.app {
  max-width: 360px;
  width: 100%;
}

.title {
  text-align: center;
  font-size: 22px;
  font-weight: 600;
  margin-bottom: 20px;
}

.grid-wrapper {
  width: 100%;
  aspect-ratio: 5 / 9;
}

.grid {
  display: grid;
  width: 100%;
  height: 100%;
  background: white;
  border: 2px solid var(--grid-color);
}

.cell {
  border: 1px solid var(--grid-color);
  display: flex;
  align-items: center;
  justify-content: center;
}

.cell img {
  width: 80%;
  height: 80%;
  object-fit: contain;
  pointer-events: none;
  transition: transform 0.4s ease, filter 0.4s ease;
}

  /* Swap animation */
.cell.swap-right img { transform: translateX(100%); }
.cell.swap-left img  { transform: translateX(-100%); }
.cell.swap-down img  { transform: translateY(100%); }
.cell.swap-up img    { transform: translateY(-100%); }

.cell img {
  transition: transform 0.25s ease, filter 0.4s ease;
}

  
/* ================= MATCH ANIMATION ================= */
.cell.match img {
  transform: scale(1.25);
  filter: drop-shadow(0 0 15px gold);
}

/* Falling animation */
.cell.fall img {
  transform: translateY(-120%);
}
  
</style>
</head>

<body>
<div class="app">
  <div class="title" id="gameTitle">Loadingâ€¦</div>
  <div class="grid-wrapper">
    <div class="grid" id="grid"></div>
  </div>
</div>

<script>
const SUPABASE_URL = "https://tppyzexttkuvcobbbmaz.supabase.co";
const SUPABASE_ANON_KEY = "sb_publishable_VZiTsc0JGVx6tVf2Zu-9uQ_-FwjGpQW";

let gridRows = 9, gridCols = 5, itemTypes = 5;
let images = {}, gridData = [];
let touchStartCell = null;
let touchStartX = 0, touchStartY = 0;

const gridEl = document.getElementById("grid");
const titleEl = document.getElementById("gameTitle");

/* ================= INIT ================= */
async function loadGames() {
  const res = await fetch(
    `${SUPABASE_URL}/rest/v1/GamesCrush?Active=eq.true&order=StartDate.desc`,
    { headers:{apikey:SUPABASE_ANON_KEY,Authorization:`Bearer ${SUPABASE_ANON_KEY}`}}
  );
  const games = await res.json();
  if (!games.length) return;
  initGame(games[0]);
}

/* ================= GAME INIT ================= */
function initGame(game) {
  gridRows = game.GridRows;
  gridCols = game.GridCols;
  itemTypes = game.ItemTypes;
  images = game.ImagesJson;

  document.documentElement.style.setProperty('--bg-color', game.BgColor);
  document.documentElement.style.setProperty('--font-color', game.FontColor);
  titleEl.textContent = game.Name;

  buildGridNoMatches();
  renderGrid();
}

/* ================= GRID BUILD ================= */
function buildGridNoMatches() {
  do {
    gridData = Array.from({length: gridRows}, () =>
      Array.from({length: gridCols}, () => randomItem())
    );
  } while (findMatches().size > 0);
}

function randomItem() {
  return Math.floor(Math.random() * itemTypes) + 1;
}

/* ================= RENDER ================= */
function renderGrid() {
  gridEl.innerHTML = "";
  gridEl.style.gridTemplateColumns = `repeat(${gridCols}, 1fr)`;
  gridEl.style.gridTemplateRows = `repeat(${gridRows}, 1fr)`;

  for (let r = 0; r < gridRows; r++) {
    for (let c = 0; c < gridCols; c++) {
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.row = r;
      cell.dataset.col = c;

      cell.addEventListener("touchstart", handleTouchStart, { passive: true });
      cell.addEventListener("touchend", handleTouchEnd, { passive: true });

      if (gridData[r][c] !== null) {
        const img = document.createElement("img");
        img.src = images[gridData[r][c]];

        // NEW: falling effect
        if (r === 0) cell.classList.add("fall");

        cell.appendChild(img);
      }

      gridEl.appendChild(cell);
    }
  }

  // Remove fall class AFTER render so animation plays
  requestAnimationFrame(() => {
    document.querySelectorAll(".cell.fall").forEach(c => c.classList.remove("fall"));
  });
}


/* ================= MATCH FIND ================= */
function findMatches() {
  const matches = new Set();

  for (let r = 0; r < gridRows; r++) {
    for (let c = 0; c < gridCols - 2; c++) {
      const v = gridData[r][c];
      if (v && v === gridData[r][c+1] && v === gridData[r][c+2]) {
        matches.add(`${r},${c}`);
        matches.add(`${r},${c+1}`);
        matches.add(`${r},${c+2}`);
      }
    }
  }

  for (let c = 0; c < gridCols; c++) {
    for (let r = 0; r < gridRows - 2; r++) {
      const v = gridData[r][c];
      if (v && v === gridData[r+1][c] && v === gridData[r+2][c]) {
        matches.add(`${r},${c}`);
        matches.add(`${r+1},${c}`);
        matches.add(`${r+2},${c}`);
      }
    }
  }

  return matches;
}

/* ================= MATCH ANIMATION ================= */
async function animateMatches(matches) {
  matches.forEach(key => {
    const [r, c] = key.split(',').map(Number);
    const cell = gridEl.querySelector(`.cell[data-row='${r}'][data-col='${c}']`);
    if (cell) cell.classList.add("match");
  });

  await new Promise(r => setTimeout(r, 400));

  matches.forEach(key => {
    const [r, c] = key.split(',').map(Number);
    gridData[r][c] = null;
  });

  applyGravity();
  refillGrid();
  renderGrid();

  const next = findMatches();
  if (next.size > 0) await animateMatches(next);
}

/* ================= GRAVITY + REFILL ================= */
function applyGravity() {
  for (let c = 0; c < gridCols; c++) {
    for (let r = gridRows - 1; r >= 0; r--) {
      if (gridData[r][c] === null) {
        for (let k = r - 1; k >= 0; k--) {
          if (gridData[k][c] !== null) {
            gridData[r][c] = gridData[k][c];
            gridData[k][c] = null;
            break;
          }
        }
      }
    }
  }
}

function refillGrid() {
  for (let r = 0; r < gridRows; r++) {
    for (let c = 0; c < gridCols; c++) {
      if (gridData[r][c] === null) gridData[r][c] = randomItem();
    }
  }
}

/* ================= TOUCH + SWAP ================= */
function handleTouchStart(e) {
  const cell = e.currentTarget;
  const t = e.touches[0];
  touchStartX = t.clientX;
  touchStartY = t.clientY;
  touchStartCell = { row:+cell.dataset.row, col:+cell.dataset.col };
}

function handleTouchEnd(e) {
  if (!touchStartCell) return;
  const t = e.changedTouches[0];
  const dx = t.clientX - touchStartX;
  const dy = t.clientY - touchStartY;

  if (Math.max(Math.abs(dx), Math.abs(dy)) < 20) return;

  let r2 = touchStartCell.row;
  let c2 = touchStartCell.col;
  Math.abs(dx) > Math.abs(dy) ? c2 += dx > 0 ? 1 : -1 : r2 += dy > 0 ? 1 : -1;

  attemptSwap(r2, c2);
  touchStartCell = null;
}

async function attemptSwap(r2, c2) {
  const { row: r1, col: c1 } = touchStartCell;
  if (r2 < 0 || c2 < 0 || r2 >= gridRows || c2 >= gridCols) return;

  const cell1 = gridEl.querySelector(`.cell[data-row='${r1}'][data-col='${c1}']`);
  const cell2 = gridEl.querySelector(`.cell[data-row='${r2}'][data-col='${c2}']`);

  const dx = c2 - c1;
  const dy = r2 - r1;

  if (dx === 1) { cell1.classList.add('swap-right'); cell2.classList.add('swap-left'); }
  if (dx === -1){ cell1.classList.add('swap-left');  cell2.classList.add('swap-right'); }
  if (dy === 1) { cell1.classList.add('swap-down');  cell2.classList.add('swap-up'); }
  if (dy === -1){ cell1.classList.add('swap-up');    cell2.classList.add('swap-down'); }

  await new Promise(r => setTimeout(r, 250));

  swap(r1, c1, r2, c2);
  renderGrid();

  const matches = findMatches();
  if (matches.size) await animateMatches(matches);
  else {
    swap(r1, c1, r2, c2);
    renderGrid();
  }
}


function swap(r1,c1,r2,c2){
  [gridData[r1][c1], gridData[r2][c2]] =
  [gridData[r2][c2], gridData[r1][c1]];
}

/* ================= START ================= */
loadGames();
</script>
</body>
</html>
