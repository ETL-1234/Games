<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<title>8 Puzzle</title>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">

<style>
  body {
    margin: 0;
    padding: 0;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: 'Inter', sans-serif;
  }

  /* ===== DOTS ===== */
  .dots {
    display: flex;
    gap: 6px;
    margin-top: 20px;
  }

  .dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: rgba(0,0,0,0.25);
  }

  .dot.active {
    background: rgba(0,0,0,0.65);
  }

  /* ===== TITLE ===== */
  .puzzle-name {
    margin: 14px 0 20px 0;
    font-size: 20px;
    font-weight: 600;
  }

  .board {
    width: 90vmin;
    height: 90vmin;
    position: relative;
    touch-action: none;
    margin-bottom: 30px;
  }

  .tile {
    position: absolute;
    width: calc(100% / 3);
    height: calc(100% / 3);
    transition: transform 160ms ease-out, box-shadow 0.5s ease-in-out;
    overflow: hidden;
    border-radius: 6px;
  }

  .tile img {
    width: 300%;
    height: 300%;
    position: absolute;
    pointer-events: none;
  }

  .tile.completed {
    box-shadow: 0 0 20px 10px rgba(255,255,255,0.3);
  }

  /* ===== LEVEL BUTTONS ===== */
  .level-buttons {
    display: flex;
    gap: 12px;
    margin-bottom: 40px;
  }

  .level-btn {
    padding: 8px 16px;
    border-radius: 20px;
    border: none;
    font-weight: 600;
    font-size: 14px;
    cursor: pointer;
  }

</style>
</head>

<body>

<div class="dots" id="dots"></div>
<div class="puzzle-name" id="puzzleName">Loading...</div>

<div class="board" id="board"></div>

<div class="level-buttons">
  <button class="level-btn" data-level="0">Easy</button>
  <button class="level-btn" data-level="1">Flow</button>
  <button class="level-btn" data-level="2">Challenge</button>
</div>

<script>

/* ================= SUPABASE ================= */

const SUPABASE_URL = "https://tppyzexttkuvcobbbmaz.supabase.co";
const SUPABASE_ANON_KEY = "sb_publishable_VZiTsc0JGVx6tVf2Zu-9uQ_-FwjGpQW";

let puzzles = [];
let currentPuzzleIndex = 0;
let IMAGE_URL = "";

/* ================= FETCH DATA ================= */

async function loadPuzzles() {

  const res = await fetch(
    `${SUPABASE_URL}/rest/v1/puzzle?type=eq.3X3&active=eq.true&limit=5`,
    {
      headers: {
        apikey: SUPABASE_ANON_KEY,
        Authorization: `Bearer ${SUPABASE_ANON_KEY}`
      }
    }
  );

  puzzles = await res.json();

  if (!puzzles.length) {
    document.getElementById("puzzleName").textContent = "No puzzles found";
    return;
  }

  buildDots();
  initPuzzle(0);
}

/* ================= INIT PUZZLE ================= */

function initPuzzle(index) {

  currentPuzzleIndex = index;
  const puzzle = puzzles[index];

  IMAGE_URL = puzzle.imageurl;

  document.body.style.background = puzzle.bgcolor;
  document.getElementById("puzzleName").textContent = puzzle.name;

  // Apply button colors
  document.querySelectorAll(".level-btn").forEach(btn => {
    btn.style.background = puzzle.buttonbgcolor;
    btn.style.color = puzzle.buttonfontcolor;
  });

  updateDots();
  shuffle(); // uses your original shuffle
}

/* ================= DOTS ================= */

function buildDots() {
  const dots = document.getElementById("dots");
  dots.innerHTML = "";

  puzzles.forEach((_, i) => {
    const d = document.createElement("div");
    d.className = "dot";
    dots.appendChild(d);
  });
}

function updateDots() {
  document.querySelectorAll(".dot").forEach((dot, i) => {
    dot.classList.toggle("active", i === currentPuzzleIndex);
  });
}

/* ================= SWIPE BETWEEN PUZZLES ================= */

let swipeStartX = 0;

document.addEventListener("touchstart", e => {
  swipeStartX = e.touches[0].clientX;
});

document.addEventListener("touchend", e => {
  let diff = e.changedTouches[0].clientX - swipeStartX;

  if (diff > 60) prevPuzzle();
  if (diff < -60) nextPuzzle();
});

function nextPuzzle() {
  let next = (currentPuzzleIndex + 1) % puzzles.length;
  initPuzzle(next);
}

function prevPuzzle() {
  let prev = (currentPuzzleIndex - 1 + puzzles.length) % puzzles.length;
  initPuzzle(prev);
}

/* ================= LEVEL BUTTON CLICK ================= */

document.querySelectorAll(".level-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    currentLevelIndex = Number(btn.dataset.level);
    shuffle();
  });
});


/* ================= ORIGINAL GAME CODE BELOW (UNCHANGED) ================= */

const GRID = 3;

const LEVELS = {
  Easy: [10, 12],
  Flow: [12, 15],
  Challenge: [15, 20]
};

const LEVEL_ORDER = ["Easy", "Flow", "Challenge"];
let currentLevelIndex = 0;

let board = [];
let lastEmpty = null;

function solvedBoard() {
  return [...Array(GRID * GRID).keys()];
}

function neighbors(index) {
  const r = Math.floor(index / GRID);
  const c = index % GRID;
  const n = [];
  if (r > 0) n.push(index - GRID);
  if (r < GRID - 1) n.push(index + GRID);
  if (c > 0) n.push(index - 1);
  if (c < GRID - 1) n.push(index + 1);
  return n;
}

function shuffle() {
  board = solvedBoard();
  let empty = board.length - 1;
  lastEmpty = null;

  const [minMoves, maxMoves] = LEVELS[LEVEL_ORDER[currentLevelIndex]];
  const moves = Math.floor(Math.random() * (maxMoves - minMoves + 1)) + minMoves;

  for (let i = 0; i < moves; i++) {
    const options = neighbors(empty).filter(n => n !== lastEmpty);
    const move = options[Math.floor(Math.random() * options.length)];
    [board[empty], board[move]] = [board[move], board[empty]];
    lastEmpty = empty;
    empty = move;
  }
// Ensure empty is bottom-right
  const finalEmptyIndex = board.indexOf(0);
  if (finalEmptyIndex !== board.length - 1) {
    [board[finalEmptyIndex], board[board.length - 1]] = [board[board.length - 1], board[finalEmptyIndex]];
    empty = board.length - 1;
  }

    // Fix last two tiles if swapped (only relevant for 3x3)
  const secondLast = board.length - 2;
  if (board[secondLast] === 7 && board[7] === 8) {
    [board[secondLast], board[7]] = [board[7], board[secondLast]];
  }
  
  render();
}
  
// ---------- Swipe movement ----------
function moveBySwipe(direction) {
  const e = board.indexOf(0);
  const r = Math.floor(e / GRID);
  const c = e % GRID;

  let target = null;
  if (direction === "up" && r < GRID - 1) target = e + GRID;
  if (direction === "down" && r > 0) target = e - GRID;
  if (direction === "left" && c < GRID - 1) target = e + 1;
  if (direction === "right" && c > 0) target = e - 1;

  if (target === null) return;

  [board[e], board[target]] = [board[target], board[e]];
  render();
}
  
// ---------- Touch handling ----------
let startX = 0;
let startY = 0;
const boardEl = document.getElementById("board");

boardEl.addEventListener("touchstart", e => {
  startX = e.touches[0].clientX;
  startY = e.touches[0].clientY;
});

boardEl.addEventListener("touchend", e => {
  const dx = e.changedTouches[0].clientX - startX;
  const dy = e.changedTouches[0].clientY - startY;

  if (Math.abs(dx) < 30 && Math.abs(dy) < 30) return;

  if (Math.abs(dx) > Math.abs(dy)) {
    moveBySwipe(dx > 0 ? "right" : "left");
  } else {
    moveBySwipe(dy > 0 ? "down" : "up");
  }
});

  // ---------- Check completion ----------
function isSolved() {
  const solved = solvedBoard();
  return board.every((val, index) => val === solved[index]);
}

function render() {
  boardEl.innerHTML = "";

  board.forEach((tile, index) => {
    if (tile === 0) return;

    const el = document.createElement("div");
    el.className = "tile";

    const r = Math.floor(index / GRID);
    const c = index % GRID;
    el.style.transform = `translate(${c * 100}%, ${r * 100}%)`;

    const img = document.createElement("img");
    const ir = Math.floor((tile - 1) / GRID);
    const ic = (tile - 1) % GRID;
    img.src = IMAGE_URL;
    img.style.left = `-${ic * 100}%`;
    img.style.top = `-${ir * 100}%`;

    el.appendChild(img);
    boardEl.appendChild(el);
  });
}

loadPuzzles();

</script>

</body>
</html>
