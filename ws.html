<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
:root {
  --bg-color: #dbe7e0;
  --draw-color: #b3d1c2;
  --grid-border: #000;
  --cell-size: 34px;
}

body {
  margin: 0;
  padding: 16px 12px 20px 12px;
  font-family:"Inter",Inter,Arial,sans-serif;
  background: var(--bg-color);
  display: flex;
  justify-content: center;
}

.app { max-width: 420px; width: 100%; }

h1 {
  text-align: center;
  margin: 0 0 16px 0;
  font-size: 20px;
}

.grid-wrapper {
  position: relative;
  padding: 12px;
}

.grid {
  display: grid;
  grid-template-columns: repeat(10, 1fr);
  gap: 4px;
  width: 100%;
  aspect-ratio: 10 / 14;
  touch-action: none;
}

.cell {
  background: #fff;
  border: 1px solid var(--grid-border);
  display: flex;
  align-items: center;
  justify-content: center;
  user-select: none;
}

svg {
  position: absolute;
  left: 12px;
  top: 12px;
  pointer-events: none;
}

.word-list {
  margin-top: 18px;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 6px 24px;
  font-size: 14px;
}

.word {
  position: relative;
}

.word.found::after {
  content: "";
  position: absolute;
  left: 0;
  right: 0;
  top: 50%;
  height: 3px;
  background: var(--draw-color);
  transform: translateY(-50%);
  border-radius: 2px;
}

.overlay {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 56px;
  font-weight: bold;
  color: rgba(0,0,0,0.65);
  opacity: 0;
  transition: opacity 1.2s ease;
  pointer-events: none;
}

.dots {
  display: flex;
  justify-content: center;
  gap: 6px;
  margin-top: 12px;
}

.dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: rgba(0,0,0,0.25);
}

.dot.active { background: rgba(0,0,0,0.6); }
</style>
</head>

<body>
<div class="app">

<h1 id="gameTitle">Loading...</h1>

<div class="grid-wrapper" id="swipeArea">
  <div class="grid" id="grid"></div>
  <svg id="svg"></svg>
  <div class="overlay" id="overlayText">Completed!</div>
</div>

<div class="word-list" id="wordList"></div>
<div class="dots" id="dots"></div>

</div>

<script>
const SUPABASE_URL = "https://tppyzexttkuvcobbbmaz.supabase.co";
const SUPABASE_ANON_KEY = "sb_publishable_VZiTsc0JGVx6tVf2Zu-9uQ_-FwjGpQW";

const COLS = 10;
const CELL = 34;
const GAP = 4;

let games = [];
let currentIndex = 0;

let LETTERS = [];
let WORDS = [];

const grid = document.getElementById("grid");
const svg = document.getElementById("svg");
const wordList = document.getElementById("wordList");
const overlay = document.getElementById("overlayText");
const dotsEl = document.getElementById("dots");

async function loadGames() {
  const response = await fetch(
    `${SUPABASE_URL}/rest/v1/GamesWordSearch?active=eq.true&order=startdate.desc`,
    {
      headers: {
        apikey: SUPABASE_ANON_KEY,
        Authorization: `Bearer ${SUPABASE_ANON_KEY}`
      }
    }
  );

  games = await response.json();

  if (!games.length) {
    document.getElementById("gameTitle").textContent = "No Games Found";
    return;
  }

  initGame(0);
  buildDots();
}

function initGame(index) {
  currentIndex = index;
  const game = games[index];

  LETTERS = game.gridlettersjson.flat();
  WORDS = game.wordjson;

  document.documentElement.style.setProperty('--bg-color', game.bgcolor);
  document.documentElement.style.setProperty('--draw-color', game.drawcolor);
  document.documentElement.style.setProperty('--grid-border', game.gridcolor);

  document.getElementById("gameTitle").textContent = game.name;

  buildGrid();
  buildWords();
  updateDots();
}

function buildGrid() {
  grid.innerHTML = "";
  svg.innerHTML = "";

  LETTERS.forEach((l, i) => {
    const c = document.createElement("div");
    c.className = "cell";
    c.textContent = l;
    c.dataset.index = i;
    grid.appendChild(c);
  });

  const rows = LETTERS.length / COLS;
  svg.setAttribute("width", COLS * CELL + (COLS - 1) * GAP);
  svg.setAttribute("height", rows * CELL + (rows - 1) * GAP);
}

function buildWords() {
  wordList.innerHTML = "";
  WORDS.forEach(w => {
    const el = document.createElement("div");
    el.className = "word";
    el.id = "word-" + w;
    el.textContent = w;
    wordList.appendChild(el);
  });
}

function buildDots() {
  dotsEl.innerHTML = "";
  games.forEach((_, i) => {
    const dot = document.createElement("div");
    dot.className = "dot";
    dotsEl.appendChild(dot);
  });
}

function updateDots() {
  document.querySelectorAll(".dot").forEach((dot, i) => {
    dot.classList.toggle("active", i === currentIndex);
  });
}

function nextGame() {
  let next = (currentIndex + 1) % games.length;
  initGame(next);
}

function prevGame() {
  let prev = (currentIndex - 1 + games.length) % games.length;
  initGame(prev);
}

let startX = 0;
document.getElementById("swipeArea").addEventListener("touchstart", e => {
  startX = e.touches[0].clientX;
});
document.getElementById("swipeArea").addEventListener("touchend", e => {
  let diff = e.changedTouches[0].clientX - startX;
  if (diff > 50) prevGame();
  if (diff < -50) nextGame();
});

/* ===== YOUR ORIGINAL GAME LOGIC BELOW (UNCHANGED) ===== */

let startIndex = null;
let direction = null;
let path = [];
let line = null;

function indexToRC(i) {
  return { r: Math.floor(i / COLS), c: i % COLS };
}

function getDir(a, b) {
  const dr = b.r - a.r;
  const dc = b.c - a.c;
  if (dr === 0 && dc === 1) return { dr: 0, dc: 1 };
  if (dc === 0 && dr === 1) return { dr: 1, dc: 0 };
  if (dr >= 1 && dc >= 1) return { dr: 1, dc: 1 };
  return null;
}

function getCellAt(x, y) {
  const el = document.elementFromPoint(x, y);
  return el?.classList.contains("cell") ? el : null;
}

function cellCenter(i) {
  const { r, c } = indexToRC(i);
  return {
    x: c * (CELL + GAP) + CELL / 2,
    y: r * (CELL + GAP) + CELL / 2
  };
}

function start(x, y) {
  const cell = getCellAt(x, y);
  if (!cell) return;

  startIndex = Number(cell.dataset.index);
  path = [startIndex];
  direction = null;

  const p = cellCenter(startIndex);

  line = document.createElementNS("http://www.w3.org/2000/svg", "line");
  line.setAttribute("x1", p.x);
  line.setAttribute("y1", p.y);
  line.setAttribute("x2", p.x);
  line.setAttribute("y2", p.y);
  line.setAttribute("stroke", "var(--draw-color)");
  line.setAttribute("stroke-width", "6");
  line.setAttribute("stroke-linecap", "round");
  line.setAttribute("stroke-opacity", "0.6");

  svg.appendChild(line);
}

function move(x, y) {
  if (!line) return;
  const cell = getCellAt(x, y);
  if (!cell) return;

  const idx = Number(cell.dataset.index);
  if (path.includes(idx)) return;

  const last = indexToRC(path[path.length - 1]);
  const curr = indexToRC(idx);

  if (!direction) {
    direction = getDir(indexToRC(startIndex), curr);
    if (!direction) return;
  }

  if (
    curr.r === last.r + direction.dr &&
    curr.c === last.c + direction.dc
  ) {
    path.push(idx);
    const p = cellCenter(idx);
    line.setAttribute("x2", p.x);
    line.setAttribute("y2", p.y);
  }
}

function end() {
  if (!line) return;

  const word = path.map(i => LETTERS[i]).join("");

  if (WORDS.includes(word)) {
    document.getElementById("word-" + word)?.classList.add("found");

    const allFound = WORDS.every(w =>
      document.getElementById("word-" + w)?.classList.contains("found")
    );

    if (allFound) {
      overlay.style.opacity = 1;
      setTimeout(() => overlay.style.opacity = 0, 2400);
    }
  } else {
    line.remove();
  }

  line = null;
  path = [];
  direction = null;
  startIndex = null;
}

document.addEventListener("mousedown", e => start(e.clientX, e.clientY));
document.addEventListener("mousemove", e => move(e.clientX, e.clientY));
document.addEventListener("mouseup", end);

document.addEventListener("touchstart", e => {
  e.preventDefault();
  start(e.touches[0].clientX, e.touches[0].clientY);
}, { passive: false });

document.addEventListener("touchmove", e => {
  e.preventDefault();
  move(e.touches[0].clientX, e.touches[0].clientY);
}, { passive: false });

document.addEventListener("touchend", e => {
  e.preventDefault();
  end();
});

loadGames();
</script>
</body>
</html>
